{"version":3,"file":"vendors-node_modules_fractalwagmi_solana-wallet-adapter_dist_esm_index_js.bundle.js","mappings":";;;;;;;;;AAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,2CAA2C;AAC3C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY,SAAS;AAChC;AACA;AACA;AACA,sCAAsC;AACtC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxHA,cAAc,mBAAO,CAAC,mGAAQ;AAC9B;;AAEA;;;;;;;;;;;;;;;;;;;;ACHkD;AACqC;AAC1C;AACe;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAoB;AACrD;AACA;AACA;AACA;AACA,2BAA2B,oEAAwB;AACnD;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe,sEAAsB,aAAa,uEAAuB,UAAU;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAS;AACpC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3GO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3CO;AACA;AACA;AACA;AACA;AACP;;;;;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;;;;;ACzB0G;AACnG;AACP,sBAAsB,mEAAwB,eAAe,+DAAoB;AACjF;AACA;AACA;AACO,qBAAqB,2CAA2C,kEAAuB,WAAW,kEAAuB,QAAQ;AACxI,sDAAsD,0BAA0B;AAChF;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,gBAAgB,KAAK;AACrB,eAAe,IAAI;AACnB,iBAAiB,MAAM;AACvB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBuD;AACL;AACR;AACF;AACJ;AACmD;AACvF;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACToD;AACF;AACS;AACb;AACS;AACvD;;;;;;;;;;;;;;;;ACL4C;AACrC;AACP,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACV4C;AACrC;AACP,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACV4C;AACrC;AACP,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACb4C;AACrC;AACP,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACb4C;AACrC;AACP,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACb4D;AAC2B;AAC5C;AACsB;AAC1D,8BAA8B,2BAA2B,4DAAgB,YAAY,sEAAsB,aAAa,uEAAuB,IAAI,IAAI;AAC9J,wDAAwD,+CAAQ;AAChE,iCAAiC,6CAAM,KAAK,qEAAiB;AAC7D;AACA,KAAK;AACL,iBAAiB,kDAAW;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,kBAAkB,kDAAW;AAC7B;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjC+Q;AAC1F;AAC5H;AAC/B;AACe;AACzC;AACA;AACA,4BAA4B,qBAAqB;AACjD,yBAAyB,qBAAqB;AAC9C,iCAAiC,qBAAqB;AACtD,4BAA4B,mFAAuB;AACnD;AACA;AACO;AACP;AACA,gCAAgC,6EAAiB,CAAC,0FAA8B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAS;AAC1C;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA,oBAAoB,iBAAiB,GAAG,MAAM;AAC9C,SAAS;AACT;AACA,iBAAiB,0GAA0C;AAC3D,2BAA2B,8EAAqB;AAChD,gCAAgC,0BAA0B;AAC1D,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA,qCAAqC,sDAAS;AAC9C;AACA;AACA;AACA;AACA,2CAA2C,6EAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAqB;AAC5C;AACA;AACA;AACA,uBAAuB,8EAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qGAAyC;AACnE,0BAA0B,mGAAuC;AACjE,0BAA0B,mFAAuB;AACjD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAW;AAC9C,mCAAmC,mFAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAW;AAC9C,mCAAmC,mFAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oHAAoD;AACrE,kCAAkC,+EAAsB;AACxD,gCAAgC,2BAA2B;AAC3D,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+FAAmC;AAC1D;AACA,aAAa;AACb;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA,oBAAoB,sBAAsB,GAAG,MAAM;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,wGAA4C;AACtE,0BAA0B,yFAA6B;AACvD,0BAA0B,mFAAuB;AACjD,0BAA0B,kFAAsB;AAChD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,wHAAwD;AACzE,kCAAkC,mFAA0B;AAC5D,gCAAgC,kCAAkC;AAClE,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAgB,CAAC,wCAAa;AACrD,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,mFAA0B;AACjD;AACA;AACA;AACA;AACA;AACA,+DAA+D,wCAAa;AAC5E;AACA;AACA,uBAAuB,mGAAuC;AAC9D;AACA,aAAa;AACb;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA,oBAAoB,cAAc,GAAG,MAAM;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,4GAAgD;AAC1E,0BAA0B,yFAA6B;AACvD,0BAA0B,mFAAuB;AACjD,0BAA0B,kFAAsB;AAChD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,gFAAuB;AAC7C;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3NO;AACP,cAAc,eAAe,EAAE,eAAe,EAAE,eAAe;AAC/D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNsD;AACtD","sources":["webpack://cryptomon/./node_modules/@fractalwagmi/solana-wallet-adapter/node_modules/base-x/src/index.js","webpack://cryptomon/./node_modules/@fractalwagmi/solana-wallet-adapter/node_modules/bs58/index.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/connection-manager.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/core/connection.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/core/constants.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/core/types.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/core/utils.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/index.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/lib/guards.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/index.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/message-signature-needed-response.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/message-signature-needed.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/solana-wallet-adapter-approved.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/transaction-signature-needed-response.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/payloads/transaction-signature-needed.js","webpack://cryptomon/./node_modules/@fractalwagmi/popup-connection/dist/esm/use-popup-connection.js","webpack://cryptomon/./node_modules/@fractalwagmi/solana-wallet-adapter/dist/esm/core/fractal-wallet-adapter-impl.js","webpack://cryptomon/./node_modules/@fractalwagmi/solana-wallet-adapter/dist/esm/core/nonce.js","webpack://cryptomon/./node_modules/@fractalwagmi/solana-wallet-adapter/dist/esm/index.js"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","import { Connection } from \"./core/connection.js\";\nimport { DEFAULT_POPUP_HEIGHT_PX, DEFAULT_POPUP_WIDTH_PX, } from \"./core/constants.js\";\nimport { PopupEvent } from \"./core/types.js\";\nimport { openPopup, validateOrigin } from \"./core/utils.js\";\nexport class ConnectionManager {\n    constructor(platform) {\n        this.platform = platform;\n        this.connection = null;\n        this.popupWindow = null;\n        this.handleMessage = (e) => {\n            var _a, _b;\n            if (!validateOrigin(e.origin)) {\n                return;\n            }\n            const validatedOrigin = e.origin;\n            if (!this.popupWindow) {\n                return;\n            }\n            if (e.data.event === PopupEvent.HANDSHAKE && !this.connection) {\n                if (!this.verifyAndResetNonce((_a = e.data.payload) === null || _a === void 0 ? void 0 : _a.nonce)) {\n                    return;\n                }\n                this.popupWindow.postMessage({\n                    event: PopupEvent.HANDSHAKE_ACK,\n                    payload: {\n                        platform: this.platform,\n                    },\n                }, validatedOrigin);\n                this.connection = new Connection(validatedOrigin, this.popupWindow);\n                (_b = this.connectionUpdatedCallback) === null || _b === void 0 ? void 0 : _b.call(this, this.connection);\n            }\n            if (!this.connection) {\n                return;\n            }\n            this.connection.runHandlersForEvent(e.data.event, e.data.payload);\n            if (e.data.event === PopupEvent.POPUP_CLOSED && this.connection) {\n                this.resetConnection();\n                this.popupWindow = null;\n            }\n        };\n    }\n    initialize() {\n        window.addEventListener('message', this.handleMessage);\n        return this;\n    }\n    tearDown() {\n        window.removeEventListener('message', this.handleMessage);\n        this.resetConnection();\n        return this;\n    }\n    open({ url, widthPx = DEFAULT_POPUP_WIDTH_PX, heightPx = DEFAULT_POPUP_HEIGHT_PX, nonce, }) {\n        var _a;\n        if ((_a = this.popupWindow) === null || _a === void 0 ? void 0 : _a.closed) {\n            this.resetConnectionAndPopupWindow();\n        }\n        if (this.popupWindow) {\n            return;\n        }\n        this.initialize();\n        if (nonce) {\n            this.nonce = nonce;\n        }\n        const left = window.screenX + (window.innerWidth - widthPx) / 2;\n        const top = window.screenY + (window.innerHeight - heightPx) / 2;\n        this.popupWindow = openPopup({\n            height: heightPx,\n            left,\n            top,\n            url,\n            width: widthPx,\n        });\n    }\n    close() {\n        if (!this.popupWindow) {\n            return;\n        }\n        this.popupWindow.close();\n        this.resetConnectionAndPopupWindow();\n    }\n    onConnectionUpdated(callback) {\n        this.connectionUpdatedCallback = callback;\n        return this;\n    }\n    getConnection() {\n        return this.connection;\n    }\n    resetConnectionAndPopupWindow() {\n        this.resetConnection();\n        this.popupWindow = null;\n    }\n    resetConnection() {\n        var _a, _b;\n        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.resetHandlers();\n        this.connection = null;\n        (_b = this.connectionUpdatedCallback) === null || _b === void 0 ? void 0 : _b.call(this, this.connection);\n    }\n    verifyAndResetNonce(uncheckedNonce) {\n        if (!this.nonce) {\n            return true;\n        }\n        const result = uncheckedNonce === this.nonce;\n        if (result) {\n            this.nonce = undefined;\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=connection-manager.js.map","export class Connection {\n    constructor(validatedOrigin, targetWindow) {\n        this.validatedOrigin = validatedOrigin;\n        this.targetWindow = targetWindow;\n        this.handlers = new Map();\n    }\n    off(event, callback) {\n        const eventCallbacks = this.handlers.get(event);\n        eventCallbacks === null || eventCallbacks === void 0 ? void 0 : eventCallbacks.delete(callback);\n    }\n    on(event, callback) {\n        var _a;\n        const eventCallbacks = (_a = this.handlers.get(event)) !== null && _a !== void 0 ? _a : new Set();\n        eventCallbacks.add(callback);\n        this.handlers.set(event, eventCallbacks);\n    }\n    send({ event, payload }) {\n        this.targetWindow.postMessage({\n            event,\n            payload,\n        }, this.validatedOrigin);\n    }\n    runHandlersForEvent(event, payload) {\n        const eventCallbacks = this.handlers.get(event);\n        if (!eventCallbacks) {\n            return;\n        }\n        for (const callback of eventCallbacks) {\n            callback(payload);\n        }\n    }\n    resetHandlers() {\n        this.handlers.clear();\n    }\n    export() {\n        return {\n            off: this.off.bind(this),\n            on: this.on.bind(this),\n            send: this.send.bind(this),\n            validatedOrigin: this.validatedOrigin,\n        };\n    }\n}\n//# sourceMappingURL=connection.js.map","export const FRACTAL_DOMAIN = 'fractal.is';\nexport const FRACTAL_DOMAIN_HTTPS = 'https://fractal.is';\nexport const FRACTAL_DOMAIN_HTTPS_WWW = 'https://www.fractal.is';\nexport const DEFAULT_POPUP_WIDTH_PX = 400;\nexport const DEFAULT_POPUP_HEIGHT_PX = 600;\n//# sourceMappingURL=constants.js.map","export var PopupEvent;\n(function (PopupEvent) {\n    PopupEvent[\"PROJECT_APPROVED\"] = \"PROJECT_APPROVED\";\n    PopupEvent[\"HANDSHAKE\"] = \"HANDSHAKE\";\n    PopupEvent[\"HANDSHAKE_ACK\"] = \"HANDSHAKE_ACK\";\n    PopupEvent[\"SIGNED_TRANSACTION\"] = \"SIGNED_TRANSACTION\";\n    PopupEvent[\"FAILED_TO_SIGN_TRANSACTION\"] = \"FAILED_TO_SIGN_TRANSACTION\";\n    PopupEvent[\"TRANSACTION_DENIED\"] = \"TRANSACTION_DENIED\";\n    PopupEvent[\"SOLANA_WALLET_ADAPTER_APPROVED\"] = \"SOLANA_WALLET_ADAPTER_APPROVED\";\n    PopupEvent[\"SOLANA_WALLET_ADAPTER_DENIED\"] = \"SOLANA_WALLET_ADAPTER_DENIED\";\n    PopupEvent[\"POPUP_CLOSED\"] = \"POPUP_CLOSED\";\n    PopupEvent[\"TRANSACTION_SIGNATURE_NEEDED\"] = \"TRANSACTION_SIGNATURE_NEEDED\";\n    PopupEvent[\"TRANSACTION_SIGNATURE_NEEDED_RESPONSE\"] = \"TRANSACTION_SIGNATURE_NEEDED_RESPONSE\";\n    PopupEvent[\"AUTH_LOADED\"] = \"AUTH_LOADED\";\n    PopupEvent[\"MESSAGE_SIGNATURE_NEEDED\"] = \"MESSAGE_SIGNATURE_NEEDED\";\n    PopupEvent[\"MESSAGE_SIGNATURE_NEEDED_RESPONSE\"] = \"MESSAGE_SIGNATURE_NEEDED_RESPONSE\";\n    PopupEvent[\"ONRAMP_FULFILLMENT_COMPLETE\"] = \"ONRAMP_FULFILLMENT_COMPLETE\";\n    PopupEvent[\"ONRAMP_REJECTED\"] = \"ONRAMP_REJECTED\";\n})(PopupEvent || (PopupEvent = {}));\nexport var Platform;\n(function (Platform) {\n    Platform[\"UNKNOWN\"] = \"UNKNOWN\";\n    Platform[\"REACT_SDK\"] = \"REACT_SDK\";\n    Platform[\"SOLANA_WALLET_ADAPTER\"] = \"SOLANA_WALLET_ADAPTER\";\n})(Platform || (Platform = {}));\n//# sourceMappingURL=types.js.map","import { FRACTAL_DOMAIN_HTTPS_WWW, FRACTAL_DOMAIN_HTTPS, DEFAULT_POPUP_HEIGHT_PX, } from \"./constants.js\";\nexport function validateOrigin(origin) {\n    return origin === FRACTAL_DOMAIN_HTTPS_WWW || origin === FRACTAL_DOMAIN_HTTPS;\n}\nconst TARGET = 'fractal:approval:popup';\nconst STATIC_POPUP_FEATURES = ['resizable', 'scrollbars=1', 'status=1'];\nexport function openPopup({ left = 0, scope = window, top = 0, width = DEFAULT_POPUP_HEIGHT_PX, height = DEFAULT_POPUP_HEIGHT_PX, url, }) {\n    return scope.open(url, TARGET, getPopupFeatures({ height, left, top, width }));\n}\nfunction getPopupFeatures({ height, left, top, width, }) {\n    return [\n        'popup',\n        `left=${left}`,\n        `top=${top}`,\n        `width=${width}`,\n        `height=${height}`,\n        ...STATIC_POPUP_FEATURES,\n    ].join(',');\n}\n//# sourceMappingURL=utils.js.map","export { PopupEvent, Platform } from \"./core/types.js\";\nexport { Connection } from \"./core/connection.js\";\nexport * from \"./use-popup-connection.js\";\nexport * from \"./connection-manager.js\";\nexport * from \"./payloads/index.js\";\nexport { DEFAULT_POPUP_HEIGHT_PX, DEFAULT_POPUP_WIDTH_PX, } from \"./core/constants.js\";\n//# sourceMappingURL=index.js.map","export function isObject(value) {\n    if (value === null) {\n        return false;\n    }\n    if (typeof value !== 'object') {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=guards.js.map","export * from \"./solana-wallet-adapter-approved.js\";\nexport * from \"./transaction-signature-needed.js\";\nexport * from \"./transaction-signature-needed-response.js\";\nexport * from \"./message-signature-needed.js\";\nexport * from \"./message-signature-needed-response.js\";\n//# sourceMappingURL=index.js.map","import { isObject } from \"../lib/guards.js\";\nexport function assertPayloadIsMessageSignatureNeededResponsePayload(payload) {\n    if (!isObject(payload)) {\n        return false;\n    }\n    if (!('decodedSignature' in payload)) {\n        return false;\n    }\n    return typeof payload.decodedSignature === 'string';\n}\n//# sourceMappingURL=message-signature-needed-response.js.map","import { isObject } from \"../lib/guards.js\";\nexport function assertPayloadIsMessageSignatureNeededPayload(payload) {\n    if (!isObject(payload)) {\n        return false;\n    }\n    if (!('decodedMessage' in payload)) {\n        return false;\n    }\n    return typeof payload.decodedMessage === 'string';\n}\n//# sourceMappingURL=message-signature-needed.js.map","import { isObject } from \"../lib/guards.js\";\nexport function assertPayloadIsSolanaWalletAdapterApproved(payload) {\n    if (!isObject(payload)) {\n        return false;\n    }\n    if (!('solanaPublicKey' in payload)) {\n        return false;\n    }\n    if (typeof payload.solanaPublicKey !== 'string') {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=solana-wallet-adapter-approved.js.map","import { isObject } from \"../lib/guards.js\";\nexport function assertPayloadIsTransactionSignatureNeededResponsePayload(payload) {\n    if (!isObject(payload)) {\n        return false;\n    }\n    if (!('signedB58Transactions' in payload)) {\n        return false;\n    }\n    if (!Array.isArray(payload.signedB58Transactions)) {\n        return false;\n    }\n    return payload.signedB58Transactions.every(value => typeof value === 'string');\n}\n//# sourceMappingURL=transaction-signature-needed-response.js.map","import { isObject } from \"../lib/guards.js\";\nexport function assertPayloadIsTransactionSignatureNeededPayload(payload) {\n    if (!isObject(payload)) {\n        return false;\n    }\n    if (!('unsignedB58Transactions' in payload)) {\n        return false;\n    }\n    if (!Array.isArray(payload.unsignedB58Transactions)) {\n        return false;\n    }\n    return payload.unsignedB58Transactions.every(value => typeof value === 'string');\n}\n//# sourceMappingURL=transaction-signature-needed.js.map","import { ConnectionManager } from \"./connection-manager.js\";\nimport { DEFAULT_POPUP_WIDTH_PX, DEFAULT_POPUP_HEIGHT_PX, } from \"./core/constants.js\";\nimport { Platform } from \"./core/types.js\";\nimport { useCallback, useEffect, useRef, useState } from 'react';\nexport const usePopupConnection = ({ enabled = true, platform = Platform.UNKNOWN, widthPx = DEFAULT_POPUP_WIDTH_PX, heightPx = DEFAULT_POPUP_HEIGHT_PX, } = {}) => {\n    const [exportedConnection, setExportedConnection] = useState(undefined);\n    const connectionManagerRef = useRef(new ConnectionManager(platform).onConnectionUpdated((connection) => {\n        setExportedConnection(connection === null || connection === void 0 ? void 0 : connection.export());\n    }));\n    const open = useCallback((url) => {\n        connectionManagerRef.current.open({\n            heightPx,\n            url,\n            widthPx,\n        });\n    }, [connectionManagerRef, widthPx, heightPx]);\n    const close = useCallback(() => {\n        connectionManagerRef.current.close();\n    }, [connectionManagerRef]);\n    useEffect(() => {\n        if (enabled) {\n            connectionManagerRef.current.initialize();\n        }\n        else {\n            connectionManagerRef.current.tearDown();\n        }\n    }, [connectionManagerRef]);\n    return {\n        close,\n        connection: exportedConnection,\n        open,\n    };\n};\n//# sourceMappingURL=use-popup-connection.js.map","import { assertPayloadIsMessageSignatureNeededResponsePayload, ConnectionManager, Platform, PopupEvent, assertPayloadIsSolanaWalletAdapterApproved, DEFAULT_POPUP_HEIGHT_PX, assertPayloadIsTransactionSignatureNeededResponsePayload, } from '@fractalwagmi/popup-connection';\nimport { WalletError, WalletNotConnectedError, WalletSignTransactionError, WalletPublicKeyError, WalletConnectionError, WalletSignMessageError, } from '@solana/wallet-adapter-base';\nimport { Transaction, PublicKey } from '@solana/web3.js';\nimport base58 from 'bs58';\nimport { createNonce } from \"./nonce.js\";\nconst UNKNOWN_ERROR_MESSAGE = 'Unknown Error';\nconst FRACTAL_DOMAIN_HTTPS = 'https://fractal.is';\nconst APPROVE_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/approve`;\nconst SIGN_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/sign`;\nconst SIGN_MESSAGE_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/sign/message`;\nconst MIN_POPUP_HEIGHT_PX = DEFAULT_POPUP_HEIGHT_PX;\nconst MAX_POPUP_WIDTH_PX = 850;\nconst LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY = 'RdxqNYxF';\nexport class FractalWalletAdapterImpl {\n    constructor() {\n        this.popupManager = new ConnectionManager(Platform.SOLANA_WALLET_ADAPTER);\n        this.publicKey = null;\n        this.connecting = false;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n    async connect() {\n        let resolve;\n        let reject;\n        const publicKeyInLocalStorage = window.localStorage.getItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY);\n        if (publicKeyInLocalStorage) {\n            this.publicKey = new PublicKey(publicKeyInLocalStorage);\n            return Promise.resolve();\n        }\n        const nonce = createNonce();\n        this.popupManager.open({\n            nonce,\n            url: `${APPROVE_PAGE_URL}/${nonce}`,\n        });\n        const handleSolanaWalletAdapterApproved = (payload) => {\n            if (!assertPayloadIsSolanaWalletAdapterApproved(payload)) {\n                reject(new WalletConnectionError('Malformed payload when setting up connection. ' +\n                    'Expected { solanaPublicKey: string } but ' +\n                    `received ${JSON.stringify(payload)}`));\n                this.popupManager.close();\n                return;\n            }\n            try {\n                this.publicKey = new PublicKey(payload.solanaPublicKey);\n                window.localStorage.setItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY, payload.solanaPublicKey);\n                resolve();\n            }\n            catch (error) {\n                const publicKeyError = new WalletPublicKeyError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n                reject(publicKeyError);\n            }\n            this.popupManager.close();\n        };\n        const handleExplicitDenialByUser = () => {\n            reject(new WalletConnectionError('The user denied the connection.'));\n            this.popupManager.close();\n        };\n        const handleClosedByUser = () => {\n            reject(new WalletConnectionError('The user denied the connection.'));\n            this.popupManager.close();\n        };\n        this.popupManager.onConnectionUpdated(connection => {\n            if (!connection) {\n                return;\n            }\n            connection.on(PopupEvent.SOLANA_WALLET_ADAPTER_APPROVED, handleSolanaWalletAdapterApproved);\n            connection.on(PopupEvent.SOLANA_WALLET_ADAPTER_DENIED, handleExplicitDenialByUser);\n            connection.on(PopupEvent.POPUP_CLOSED, handleClosedByUser);\n        });\n        return new Promise((promiseResolver, promiseRejector) => {\n            resolve = promiseResolver;\n            reject = promiseRejector;\n        });\n    }\n    async disconnect() {\n        this.popupManager.tearDown();\n        this.publicKey = null;\n        window.localStorage.removeItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY);\n    }\n    async signTransaction(transaction) {\n        try {\n            this.checkWalletReadiness();\n            const result = await this.signTransactions([transaction]);\n            return result[0];\n        }\n        catch (error) {\n            let errorToThrow = error;\n            if (!(error instanceof WalletError)) {\n                errorToThrow = new WalletSignTransactionError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n            }\n            throw errorToThrow;\n        }\n    }\n    async signAllTransactions(transactions) {\n        try {\n            this.checkWalletReadiness();\n            const result = await this.signTransactions(transactions);\n            return result;\n        }\n        catch (error) {\n            let errorToThrow = error;\n            if (!(error instanceof WalletError)) {\n                errorToThrow = new WalletSignTransactionError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n            }\n            throw errorToThrow;\n        }\n    }\n    async signMessage(encodedMessage) {\n        const decodedMessage = new TextDecoder().decode(encodedMessage);\n        let resolve;\n        let reject;\n        const handleMessageSignatureNeededResponse = (payload) => {\n            if (!assertPayloadIsMessageSignatureNeededResponsePayload(payload)) {\n                const error = new WalletSignMessageError('Malformed payload when signing message. ' +\n                    'Expected { decodedSignature: string } ' +\n                    `but received ${JSON.stringify(payload)}`);\n                reject(error);\n                this.popupManager.close();\n                return;\n            }\n            const encodedSignature = Uint8Array.from(payload.decodedSignature.split(',').map(n => Number(n)));\n            resolve(encodedSignature);\n            this.popupManager.close();\n        };\n        const handleClosedOrDeniedByUser = () => {\n            reject(new WalletSignMessageError('The user did not approve the message'));\n            this.popupManager.close();\n        };\n        const handleAuthLoaded = () => {\n            var _a;\n            const payload = {\n                decodedMessage,\n            };\n            (_a = this.popupManager.getConnection()) === null || _a === void 0 ? void 0 : _a.send({\n                event: PopupEvent.MESSAGE_SIGNATURE_NEEDED,\n                payload,\n            });\n        };\n        const nonce = createNonce();\n        this.popupManager.open({\n            heightPx: Math.max(MIN_POPUP_HEIGHT_PX, Math.floor(window.innerHeight * 0.8)),\n            nonce,\n            url: `${SIGN_MESSAGE_PAGE_URL}/${nonce}`,\n            widthPx: Math.min(MAX_POPUP_WIDTH_PX, Math.floor(window.innerWidth * 0.8)),\n        });\n        this.popupManager.onConnectionUpdated(connection => {\n            if (!connection) {\n                return;\n            }\n            connection.on(PopupEvent.MESSAGE_SIGNATURE_NEEDED_RESPONSE, handleMessageSignatureNeededResponse);\n            connection.on(PopupEvent.TRANSACTION_DENIED, handleClosedOrDeniedByUser);\n            connection.on(PopupEvent.POPUP_CLOSED, handleClosedOrDeniedByUser);\n            connection.on(PopupEvent.AUTH_LOADED, handleAuthLoaded);\n        });\n        return new Promise((promiseResolver, promiseRejector) => {\n            resolve = promiseResolver;\n            reject = promiseRejector;\n        });\n    }\n    async signTransactions(transactions) {\n        let resolve;\n        let reject;\n        const handleTransactionSignatureNeededResponse = (payload) => {\n            if (!assertPayloadIsTransactionSignatureNeededResponsePayload(payload)) {\n                const error = new WalletSignTransactionError('Malformed payload when signing transactions. ' +\n                    'Expected { signedB58Transactions: string[] } ' +\n                    `but received ${JSON.stringify(payload)}`);\n                reject(error);\n                this.popupManager.close();\n                return;\n            }\n            const signedTransactions = payload.signedB58Transactions.map(signedB58Transaction => {\n                return Transaction.from(base58.decode(signedB58Transaction));\n            });\n            resolve(signedTransactions);\n            this.popupManager.close();\n        };\n        const handleClosedOrDeniedByUser = () => {\n            reject(new WalletSignTransactionError('The user did not approve the transaction'));\n            this.popupManager.close();\n        };\n        const handleAuthLoaded = () => {\n            var _a;\n            const payload = {\n                unsignedB58Transactions: transactions.map(t => base58.encode(t.serializeMessage())),\n            };\n            (_a = this.popupManager.getConnection()) === null || _a === void 0 ? void 0 : _a.send({\n                event: PopupEvent.TRANSACTION_SIGNATURE_NEEDED,\n                payload,\n            });\n        };\n        const nonce = createNonce();\n        this.popupManager.open({\n            heightPx: Math.max(MIN_POPUP_HEIGHT_PX, Math.floor(window.innerHeight * 0.8)),\n            nonce,\n            url: `${SIGN_PAGE_URL}/${nonce}`,\n            widthPx: Math.min(MAX_POPUP_WIDTH_PX, Math.floor(window.innerWidth * 0.8)),\n        });\n        this.popupManager.onConnectionUpdated(connection => {\n            if (!connection) {\n                return;\n            }\n            connection.on(PopupEvent.TRANSACTION_SIGNATURE_NEEDED_RESPONSE, handleTransactionSignatureNeededResponse);\n            connection.on(PopupEvent.TRANSACTION_DENIED, handleClosedOrDeniedByUser);\n            connection.on(PopupEvent.POPUP_CLOSED, handleClosedOrDeniedByUser);\n            connection.on(PopupEvent.AUTH_LOADED, handleAuthLoaded);\n        });\n        return new Promise((promiseResolver, promiseRejector) => {\n            resolve = promiseResolver;\n            reject = promiseRejector;\n        });\n    }\n    checkWalletReadiness() {\n        if (this.publicKey === null) {\n            throw new WalletNotConnectedError('`publicKey` is null. Did you forget to call `.connect()`?');\n        }\n    }\n}\n//# sourceMappingURL=fractal-wallet-adapter-impl.js.map","export function createNonce() {\n    return `${randomString()}${randomString()}${randomString()}`;\n}\nfunction randomString() {\n    return (Math.random() + 1).toString(36).substring(7);\n}\n//# sourceMappingURL=nonce.js.map","export * from \"./core/fractal-wallet-adapter-impl.js\";\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}