{"version":3,"file":"vendors-node_modules_censo-custody_solana-wallet-adapter_lib_esm_index_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;AAA6F;AACrE;AACY;AACS;AAC7C,iCAAiC,MAAM,OAAO,sEAAyB;AAChE,0BAA0B,uDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sDAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,kBAAkB,OAAO;AACpE;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gDAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAY,CAAC,MAAM;AACzC,eAAe,iEAAoB,uBAAuB,8CAA8C;AACxG;AACA,mBAAmB,wCAAW;AAC9B,kBAAkB,MAAM;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4DAA4D,gDAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAA4C,uCAAuC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAM;AAC7C;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,oDAAoD,wCAAwC;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACzQkC;AAClC","sources":["webpack://cryptomon/./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js","webpack://cryptomon/./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js"],"sourcesContent":["import { Message, PublicKey, SIGNATURE_LENGTH_IN_BYTES, Transaction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\nexport class CensoWallet extends EventEmitter {\n    constructor() {\n        super();\n        this.url = 'https://wallet.censocustody.com';\n        this.cleanUp = () => {\n            [...this._timers].forEach(t => this.clearTimer(t));\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.close();\n            }\n            this._wallet = null;\n            this.emit('disconnected');\n        };\n        this.clearTimer = (timer) => {\n            this._timers = this._timers.filter(t => t != timer);\n            window.clearInterval(timer);\n        };\n        this.instructionsToSerializableInstructions = (instructions) => instructions.map(i => {\n            return {\n                'programId': i.programId.toBase58(),\n                'accountMetas': i.keys.map(k => {\n                    return {\n                        address: k.pubkey.toBase58(),\n                        signer: k.isSigner,\n                        writable: k.isWritable,\n                    };\n                }),\n                'data': window.btoa(String.fromCharCode(...i.data)),\n            };\n        });\n        this.handleWalletMessage = (data) => {\n            var _a, _b, _c;\n            if (data.type == \"connected\") {\n                this._connecting = false;\n                if (!data.error) {\n                    this.isLoggedIn = true;\n                    if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n                        this._publicKey = new PublicKey(data.connected.publicKey);\n                    }\n                }\n            }\n            else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n                const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n                    }\n                }\n            }\n            else if (data.type == \"signTransaction\") {\n                const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;\n                    }\n                }\n            }\n        };\n        this.isLoggedIn = false;\n        this._pendingTransactions = {};\n        this._pendingTransactionErrors = {};\n        this._timers = [];\n        this._wallet = null;\n        this._connecting = false;\n        this._publicKey = null;\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data);\n        });\n    }\n    async connect(url) {\n        try {\n            this.url = url || this.url;\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true;\n            this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false;\n                throw new Error(\"Unable to connect to wallet\");\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet.closed) {\n                    this.cleanUp();\n                }\n                else if (this._wallet) {\n                    this._wallet.postMessage({ type: 'heartbeat' }, this.url);\n                }\n            }, 100));\n            return new Promise((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey);\n                    }\n                    else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Censo\"));\n                    }\n                }, 100);\n                this._timers.push(timer);\n            });\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signTransaction(transaction) {\n        this.verifyCanSignRequests([transaction]);\n        try {\n            return this.signOneTransaction(transaction);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        this.verifyCanSignRequests(transactions);\n        try {\n            return this.signMultipleTransactions(transactions);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async sendTransaction(transaction, connection, options) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet)\n                throw new Error(\"Not Connected\");\n            const transactionIdentifier = uuidv4();\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n            if (signers && signers.length > 0) {\n                return new Promise((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null;\n                        (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature.toString('base64')\n                                    };\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature);\n                                pendingTransactionError && reject(pendingTransactionError);\n                            }\n                        }, 100);\n                        this._timers.push(timer);\n                    }).catch((error) => {\n                        reject(error);\n                        throw error;\n                    });\n                });\n            }\n            else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n                return new Promise((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature);\n                            pendingTransactionError && reject(pendingTransactionError);\n                        }\n                    }, 100);\n                    this._timers.push(timer);\n                });\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    buildTransaction(pendingTransaction) {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));\n        return Transaction.populate(message, Array.from({ length: message.header.numRequiredSignatures }, (_v, i) => {\n            let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());\n            return bs58.encode(sigPubkeyPair\n                ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                : DEFAULT_SIGNATURE_BUFFER);\n        }));\n    }\n    verifyCanSignRequests(transactions) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Censo does not support this signing mode\");\n            }\n        });\n    }\n    signOneTransaction(transaction, transactionIdentifier = uuidv4()) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer);\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction));\n                    pendingTransactionError && reject(pendingTransactionError);\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n    signMultipleTransactions(transactions) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: uuidv4()\n            };\n        });\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier);\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null);\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signAllTransactions\", signAllTransactions: { transactions: serializedTransactions } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId]);\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId]);\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer);\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)));\n                }\n                else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer);\n                    reject(pendingTransactionErrors.find((e) => e != null));\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n}\n//# sourceMappingURL=censocustody.js.map","export * from './censocustody.js';\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}